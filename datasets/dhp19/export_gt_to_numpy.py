import argparse
import numpy as np
import os
import pathlib

import datasets.dhp19.utils.constants as dhp19_const
import datasets.utils.mat_files as mat_utils
import datasets.dhp19.utils.parsing as dhp19_parse


def extract_2d_poses(data_events, data_vicon, projection_mat, window_size):
    """
    Extracts a 2d pose for each window of events.
    For each window of events generated by the specified camera, the matching Vicon poses are selected and averaged
    to create a single pose for each window, and finally projected to a 2d plane using a projection matrix.
    The matching of events and poses is based on timestamps.

    Parameters:
        data_events (dict): dictionary containing event data from all cameras, as generated by the preprocess.m matlab script
        data_vicon (dict): dictionary containing Vicon data, provided by DHP19 dataset
        projection_mat (numpy array): array with shape (4, 3) containing the projection matrix
        camera_id (int): camera id, must belong to range [0, 3]
        window_size (int): maximum number of events per window (DHP19 default is 7500)
    Returns:
        a numpy array with shape (num_of_windows, num_of_dhp19_joints, 2) containing the 2d poses
    """

    avg_poses_3d, ts = dhp19_parse.extract_3d_poses(data_events, data_vicon, window_size)

    avg_poses_2d = dhp19_parse.project_poses_to_2d(avg_poses_3d, np.transpose(projection_mat))

    # is this needed?
    # avg_poses_2d = avg_poses_2d.astype(np.uint16)

    return avg_poses_2d, ts


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Extract 2D or 3D ground-truth poses from DHP19 preprocessed data files \
                                                 and save them to .npy files')
    parser.add_argument('-e', '--events_file_path', help='path to preprocessed events .mat file', required=True)
    parser.add_argument('-v', '--vicon_file_path', help='path to Vicon .mat files', required=True)
    parser.add_argument('-p', '--projection_matrices_folder', help='path to the projection matrix .npy file used for extracting 2D poses (use P4.npy for cam_id 0, P1 for cam_id 1, P3 for cam_id 2 and P2 for cam_id 3)', required=True)
    parser.add_argument('-w', '--window_size', help=f'approximate number of events used to compute an event frame (default value for DHP19 is {dhp19_const.DHP19_CAM_FRAME_EVENTS_NUM})', default=dhp19_const.DHP19_CAM_FRAME_EVENTS_NUM)
    parser.add_argument('-o', '--output_folder', help='path to the folder where output .npy file will be saved; if not present, the folder will be created', required=True)
    parser.add_argument('-td', '--two_dimensional', dest='two_dimensional', help='flag specifying if 2D poses will be extracted; if not specified, 3D poses will be extracted', action='store_true')
    parser.set_defaults(two_dimensional=False)
    args = parser.parse_args()

    # read data from .mat files
    data_events = mat_utils.loadmat(args.events_file_path)
    data_vicon = mat_utils.loadmat(args.vicon_file_path)

    proj_matrices_folder = pathlib.Path(args.p)
    proj_matrices_folder = pathlib.Path(proj_matrices_folder.resolve())

    if args.two_dimensional:
        for cn in range(dhp19_const.DHP19_CAM_NUM):
            proj_mat = dhp19_parse.get_projection_matrix(cn, proj_matrices_folder)
            poses, ts = extract_2d_poses(data_events, data_vicon, proj_mat, args.window_size)
            file_name = f'2d_poses_cam_{cn}_{args.window_size}.npy'
            ts_file_name = f'2d_poses_cam_{cn}_{args.window_size}_ts.npy'
    else:
        poses, ts = dhp19_parse.extract_3d_poses(data_events, data_vicon, args.window_size)
        file_name = f'3d_poses_{args.window_size}.npy'
        ts_file_name = f'3d_poses_{args.window_size}_ts.npy'

    os.makedirs(args.output_folder, exist_ok=True)

    np.save(os.path.join(args.output_folder, file_name), poses, allow_pickle=False)
    np.save(os.path.join(args.output_folder, ts_file_name), ts, allow_pickle=False)

//TODO license

#pragma once

#include <tuple>
#include <vector>
#include <array>
#include <iostream>
#include <string>

namespace hpecore {
using skeleton = std::vector<std::tuple<double, double>>;

typedef struct {
    float u;
    float v;
} joint ;

typedef std::array<joint, 13> sklt;
enum skltJoint {head, shoulderR, shoulderL, elbowR, elbowL,
             hipL, hipR, handR, handL, kneeR, kneeL, footR, footL};

inline skltJoint str2enum(const std::string& str)
{
    if(str == "head") return head;
    else if(str == "shoulderR") return shoulderR;
    else if(str == "shoulderL") return shoulderL;
    else if(str == "elbowR") return elbowR;
    else if(str == "elbowL") return elbowL;
    else if(str == "hipL") return hipL;
    else if(str == "hipR") return hipR;
    else if(str == "handR") return handR;
    else if(str == "handL") return handL;
    else if(str == "kneeR") return kneeR;
    else if(str == "kneeL") return kneeL;
    else if(str == "footR") return footR;
    else if(str == "footL") return footL;
}

// mapping between DHP19 joints and indices of joints generated by openpose using the COCO_18 body model
enum DHP19_TO_COCO_18_INDICES
{
    head=0,  // no head in coco, use nose
    shoulderR=2,
    shoulderL=5,
    elbowR=3,
    elbowL=6,
    hipL=11,
    hipR=8,
    handR=4,  // no right hand in coco, use right wrist
    handL=7,  // no left hand in coco, use left wrist
    kneeR=9,
    kneeL=12,
    footR=10,  // no right foot in coco, use right ankle
    footL=13  // no left foot in coco, use left ankle
};

inline void print_skeleton(const skeleton s) 
{
    for(auto &t : s)
        std::cout << std::get<0>(t) << " " << std::get<1>(t) << std::endl;
}

inline void print_sklt(const sklt s) 
{
    for(auto& j : s)
        std::cout << j.u << " " << j.v << std::endl;
}

inline std::string skeleton_to_string(const skeleton s)
{
    std::string out;
    out.reserve(2500);  // (4 characters (one for each coordinate number, max 4) + 1 empty space) * 2 (x, y) * 25 (max number of joints)
    for(auto &t : s)
        out += std::get<0>(t) + " " + std::get<1>(t) + " ";

    return out;
}

inline skeleton coco18_to_dhp19(const skeleton skeleton_in)
{
    skeleton skeleton_out;

    skeleton_out.push_back(std::make_tuple(std::get<0>(DHP19_TO_COCO_18_INDICES::head), std::get<1>(DHP19_TO_COCO_18_INDICES::head)));
    skeleton_out.push_back(std::make_tuple(std::get<0>(DHP19_TO_COCO_18_INDICES::shoulderR), std::get<1>(DHP19_TO_COCO_18_INDICES::shoulderR)));
    skeleton_out.push_back(std::make_tuple(std::get<0>(DHP19_TO_COCO_18_INDICES::shoulderL), std::get<1>(DHP19_TO_COCO_18_INDICES::shoulderL)));
    skeleton_out.push_back(std::make_tuple(std::get<0>(DHP19_TO_COCO_18_INDICES::elbowR), std::get<1>(DHP19_TO_COCO_18_INDICES::elbowR)));
    skeleton_out.push_back(std::make_tuple(std::get<0>(DHP19_TO_COCO_18_INDICES::elbowL), std::get<1>(DHP19_TO_COCO_18_INDICES::elbowL)));
    skeleton_out.push_back(std::make_tuple(std::get<0>(DHP19_TO_COCO_18_INDICES::hipL), std::get<1>(DHP19_TO_COCO_18_INDICES::hipL)));
    skeleton_out.push_back(std::make_tuple(std::get<0>(DHP19_TO_COCO_18_INDICES::hipR), std::get<1>(DHP19_TO_COCO_18_INDICES::hipR)));
    skeleton_out.push_back(std::make_tuple(std::get<0>(DHP19_TO_COCO_18_INDICES::handR), std::get<1>(DHP19_TO_COCO_18_INDICES::handR)));
    skeleton_out.push_back(std::make_tuple(std::get<0>(DHP19_TO_COCO_18_INDICES::handL), std::get<1>(DHP19_TO_COCO_18_INDICES::handL)));
    skeleton_out.push_back(std::make_tuple(std::get<0>(DHP19_TO_COCO_18_INDICES::kneeR), std::get<1>(DHP19_TO_COCO_18_INDICES::kneeR)));
    skeleton_out.push_back(std::make_tuple(std::get<0>(DHP19_TO_COCO_18_INDICES::kneeL), std::get<1>(DHP19_TO_COCO_18_INDICES::kneeL)));
    skeleton_out.push_back(std::make_tuple(std::get<0>(DHP19_TO_COCO_18_INDICES::footR), std::get<1>(DHP19_TO_COCO_18_INDICES::footR)));
    skeleton_out.push_back(std::make_tuple(std::get<0>(DHP19_TO_COCO_18_INDICES::footL), std::get<1>(DHP19_TO_COCO_18_INDICES::footL)));

    return skeleton_out;
}

}